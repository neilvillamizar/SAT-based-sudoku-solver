#include <vector>
#include <iostream>
#include <algorithm>
#include <utility>
#include <queue>
#include <cassert>
#include "sat_solver.hpp"

bool SATSolver::IsSAT() { 

    // First, we reduce every clause of size 1 and
    // implicate values from them. This is done so
    // the logic of algorithm below holds
    if (!RemoveSingleVars()) {

        // conflict found
        return false;
    }

    while (true) { 
        
        if (!Decide()) {            
            // no more vars to decide, 
            // then expresion is satisfiable
            return true;
        }

        while (!PropagateDecision()) {

            // conflict has been found, then we have to undo
            // lat decision that we made and try the other way

            if (!ChangeDecision()) {

                // no more decisions to change, still conflict
                // happened. Then, expresion is not satisfiable
                return false;
            }
        }
    }    
}

bool SATSolver::RemoveSingleVars() {

    // checking every clause
    for(Clause *clause : clauses) {

        if (clause->size == 1) {

            int p = clause->vars[0];
            bool val = p > 0;
            int idx_p = abs(p);

            assignments.push({idx_p, val});
        }
    } 
    
    return PropagateDecision();
}

bool SATSolver::Decide() {

    // search for the next element yet to decide
    while(current_var <= NVar && decided[current_var]) 
        current_var++;    

    if (current_var <= NVar) { 
        // stacking the new decision
        Decision new_decision(current_var,true);
        decisions.push(new_decision);
        assignments.push({current_var,true});
        return true;
    }
    
    // no more vars to decide
    return false;
}

bool SATSolver::PropagateDecision() {

    while (!assignments.empty()) {
        
        Assignment assignment = assignments.front();
        assignments.pop();

        int var = assignment.first;
        bool val = assignment.second;
        
        // Checking for conflicts
        if (decided[var] && (value[var] != val)) {
            // if conflict is found, report failure
            return false;
        }

        // setting value
        decided[var] = true;
        value[var] = val;
        // remebering the change we are doing for this state
        if (!decisions.empty()) {
            Decision &last_decision = decisions.top();
            last_decision.implications.push_back(var);    
        }
        
        // now we want to find the implications generated by this 
        // assignation and push them to the queue
        DeduceImplications(val ? -var : var);
    }
    return true;
}


void SATSolver::DeduceImplications(int literal) {

    std::vector<int>::iterator it;
    int lit_idx = mapIdx(literal);

    // iterating through clauses that are whatched for the current literal
    for(it = watched[lit_idx].begin(); it != watched[lit_idx].end();) {
        
        int clause_idx = (*it);
        Clause *clause = clauses[clause_idx];

        // checking if we can replace the watched literal
        int new_lit_idx = ReplaceWatchedLiteral(clause, literal);
        
        if (new_lit_idx == -1) {

            // no replacement found, then we check if we
            // generated a new implication
            Assignment implication = GetImplication(clause);

            // checking if the implicated value was already decided
            if (implication.first != 0) {
                // adding it to the queue
                assignments.push(implication);
            }

            it++;
            
        } else {    
            // then we erase from the current list and add it to 
            // the list belonging to the new literal
            watched[new_lit_idx].push_back(clause_idx);
            it = watched[lit_idx].erase(it);
        }
    }
}

bool SATSolver::ChangeDecision () {

    while (!decisions.empty()) {

        Decision &last_decision = decisions.top();

        // Discard all implications decudec by this decision
        for(int var : last_decision.implications) {
            decided[var] = false;
        }

        while(!assignments.empty()) {
            assignments.pop();
        }

        if (!last_decision.tried_both) {
            
            last_decision.value =  last_decision.value^true;
            last_decision.tried_both = true;
            last_decision.implications.clear();
            assignments.push({last_decision.var, last_decision.value});
            current_var = last_decision.var;
            return true;

        } else {
            decisions.pop();
        }
    }
    return false;
}


Assignment SATSolver::GetImplication(Clause *clause) {
    
    Assignment implication(0, false);

    std::vector<int> &vars = clause->vars;
    int &fwatch = clause->fwatch;
    // the implication can only be on fwatch
    if (!decided[ abs(vars[fwatch]) ]) {
        implication.first = abs(vars[fwatch]);
        implication.second = vars[fwatch] > 0;
    }
    
    return implication;
}

int SATSolver::ReplaceWatchedLiteral(Clause *clause, int var) {

    std::vector<int> &vars = clause->vars;
    int &fwatch = clause->fwatch;
    int &swatch = clause->swatch;
    int &size = clause->size;

    if (vars[fwatch] == var) {
        std::swap(fwatch, swatch);
    }

    for(int new_watch = 0; new_watch < size; new_watch++) {

        if (fwatch == new_watch || swatch == new_watch) { 
            continue;
        }
        
        // literal that we are considering
        int curr_literal = vars[new_watch];
        // its variable index
        int cur_idx = abs(curr_literal);
        // value desired for current literal
        bool des_value = curr_literal > 0;

        // if there is a literal that satisfy our clause,
        // we pick it as our new watched literal
        // if there is a literal that is not assigned,
        // it is our new watched literal
        if ((decided[cur_idx] && value[cur_idx] == des_value) ||
            !decided[cur_idx]) {
            swatch = new_watch;
            return mapIdx(curr_literal);
        }
    }

    // not replacement found
    return -1;
}

void SATSolver::ReadExpression() {

    char start_code;
    std::string format;
    std::string line;

    while (std::cin >> start_code) {
        
        if (start_code == 'c') {
            // line is a comment, skip
            getline(std::cin, line);
            continue;
        }

        break;
    }

    assert(start_code == 'p');

    // only support for cnf
    std::cin >> format;
    assert(format == "cnf");

    std::cin >> NVar >> NClauses;

    int clauses_read = 0;
    Clause *clause = new Clause();

    while (clauses_read < NClauses) {
        
        int p;
        std::cin >> p;

        if (p == 0) {
        
            clause->idx = clauses_read;
            clause->size = clause->vars.size();
            clauses.push_back(clause);
            clauses_read++;
            if (clauses_read != NClauses) clause = new Clause();
        
        } else {
            clause->vars.push_back(p);
        }
    }    
}

void SATSolver::PrintResult() {

    // Printing start code y format (only support for cnf)
    std::cout << "s" << " " << "cnf" << " ";
    std::cout << (int)SAT << " " << NVar << std::endl;
    for(int i = 1; i <= NVar && SAT; i++) {
        std::cout << "v" << " " << (value[i] ? i : -i) << std::endl;
    } 
}

void SATSolver::Initialize() {

    decided.resize(NVar+1, false);
    value.resize(NVar+1);
    watched.resize(2*NVar+1);
    current_var = 1;
    for(int i = 0; i < NClauses; i++) {
    
        Clause *clause = clauses[i];
        
        if (clause->size == 1)
            continue;
        
        for (size_t j = 0; j < 2; j++) {
            watched[mapIdx(clause->vars[j])].push_back(i);
        }
    }
}

bool SATSolver::SolveExpression() {

    Initialize();
    SAT = IsSAT();
    return SAT;
}